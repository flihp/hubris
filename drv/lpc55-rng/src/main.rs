// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

//! Driver for the LPC55 random number generator.
//!
//! Use the rng-api crate to interact with this driver.

#![no_std]
#![no_main]

mod config;

use config::DataRegion;
use core::{mem::size_of, slice};
use drv_lpc55_syscon_api::{Peripheral, Syscon};
use drv_rng_api::RngError;
use hubpack::SerializedSize;
use idol_runtime::{ClientError, NotificationHandler, RequestError};
use lib_dice::{
    persistid_cert_tmpl::{SUBJECT_CN_LENGTH, SUBJECT_CN_RANGE},
    CertData, RngData, RngSeed, SeedBuf,
};
use rand_chacha::ChaCha20Rng;
use rand_core::block::{BlockRng, BlockRngCore};
use rand_core::{impls, Error, RngCore, SeedableRng};
use ringbuf::{ringbuf, ringbuf_entry};
use serde::Deserialize;
use sha3::{Digest, Sha3_256};
use stage0_handoff::{HandoffData, HandoffDataLoadError};
use userlib::*;

// This file is generated by the crate build.rs. It contains instances of
// config::DataRegion structs describing regions of memory configured &
// exposed to this task by the hubris build.
mod build {
    include!(concat!(env!("OUT_DIR"), "/rng-config.rs"));
}

use build::{CERT_DATA, RNG_DATA};

use lpc55_pac as device;

task_slot!(SYSCON, syscon_driver);

#[derive(Copy, Clone, PartialEq)]
enum Trace {
    Sn([u8; SUBJECT_CN_LENGTH]),
    FillingBytes(usize),
    HandoffError(HandoffDataLoadError),
    Recurse(usize, usize),
    Reseed,
    ReseedingFill(usize),
    None,
}

ringbuf!(Trace, 16, Trace::None);

struct Lpc55Core {
    pmc: &'static lpc55_pac::pmc::RegisterBlock,
    rng: &'static lpc55_pac::rng::RegisterBlock,
    syscon: Syscon,
}

impl Lpc55Core {
    fn new() -> Self {
        let syscon = SYSCON.get_task_id();
        Lpc55Core {
            pmc: unsafe { &*device::PMC::ptr() },
            rng: unsafe { &*device::RNG::ptr() },
            syscon: Syscon::from(syscon),
        }
    }
}

/// Implementing the `generate` function from the `BlockRngCore` trait gets
/// us a free implementation of BlockRng
impl BlockRngCore for Lpc55Core {
    type Item = u32;
    type Results = [u32; 1];

    fn generate(&mut self, results: &mut Self::Results) {
        results[0] = self.rng.random_number.read().bits();
    }
}

struct Lpc55Rng(BlockRng<Lpc55Core>);

impl Lpc55Rng {
    fn new() -> Self {
        Lpc55Rng(BlockRng::new(Lpc55Core::new()))
    }

    fn init(&self) {
        self.0
            .core
            .pmc
            .pdruncfg0
            .modify(|_, w| w.pden_rng().poweredon());

        self.0.core.syscon.enable_clock(Peripheral::Rng);

        self.0.core.syscon.enter_reset(Peripheral::Rng);
        self.0.core.syscon.leave_reset(Peripheral::Rng);
    }
}

impl RngCore for Lpc55Rng {
    fn next_u32(&mut self) -> u32 {
        self.0.next_u32()
    }
    fn next_u64(&mut self) -> u64 {
        self.0.next_u64()
    }
    fn fill_bytes(&mut self, bytes: &mut [u8]) {
        self.0.fill_bytes(bytes)
    }
    fn try_fill_bytes(&mut self, bytes: &mut [u8]) -> Result<(), Error> {
        if self.0.core.pmc.pdruncfg0.read().pden_rng().bits() {
            return Err(RngError::PoweredOff.into());
        }

        self.0.try_fill_bytes(bytes)
    }
}

// low-budget rand::rngs::adapter::ReseedingRng w/o fork stuff
struct ReseedingRng<T: SeedableRng> {
    inner: T,
    rng: Lpc55Rng,
    threshold: usize,
    bytes_until_reseed: usize,
}

const RNG_BYTE_COUNT: usize = 1024;
const RNG_BUF_SIZE: usize = 32;

impl<T> ReseedingRng<T>
where
    T: SeedableRng<Seed = [u8; 32]> + RngCore,
{
    fn new(
        seed: RngSeed,
        mut rng: Lpc55Rng,
        sn: &[u8; SUBJECT_CN_LENGTH],
        threshold: usize,
    ) -> Result<Self, Error> {
        use ::core::usize::MAX;

        let threshold = if threshold == 0 { MAX } else { threshold };

        // mix platform unique seed drived by measured boot
        let mut mixer = Sha3_256::new();
        mixer.update(seed.as_bytes());

        // mix in unique platform id
        mixer.update(sn);

        // with 1KB from hardware RNG
        let mut bytes = [0u8; RNG_BUF_SIZE];
        for _ in 0..(RNG_BYTE_COUNT / RNG_BUF_SIZE) {
            rng.try_fill_bytes(&mut bytes)?;
            mixer.update(bytes);
        }

        let inner = T::from_seed(mixer.finalize().into());

        Ok(ReseedingRng {
            inner,
            rng,
            threshold,
            bytes_until_reseed: threshold,
        })
    }

    /// Reseed the inner PRNG
    fn reseed(&mut self) -> Result<(), Error> {
        ringbuf_entry!(Trace::Reseed);

        let mut buf = [0u8; 32];
        let mut mixer = Sha3_256::new();

        // mix 32 bytes from current RNG instance
        self.inner.try_fill_bytes(&mut buf)?;
        mixer.update(buf);

        // w/ another 1k from rng
        for _ in 0..32 {
            self.rng.try_fill_bytes(&mut buf)?;
            mixer.update(buf);
        }

        // seed new RNG instance
        self.inner = T::from_seed(mixer.finalize().into());

        // reset threshold for next reseed
        self.bytes_until_reseed = self.threshold;

        Ok(())
    }
}

impl<T> RngCore for ReseedingRng<T>
where
    T: SeedableRng<Seed = [u8; 32]> + RngCore,
{
    fn next_u32(&mut self) -> u32 {
        impls::next_u32_via_fill(self)
    }
    fn next_u64(&mut self) -> u64 {
        impls::next_u64_via_fill(self)
    }
    fn fill_bytes(&mut self, dest: &mut [u8]) {
        self.try_fill_bytes(dest)
            .expect("Failed to get entropy from RNG.")
    }
    fn try_fill_bytes(&mut self, dest: &mut [u8]) -> Result<(), Error> {
        let num_bytes = dest.len();
        ringbuf_entry!(Trace::ReseedingFill(num_bytes));

        if num_bytes < self.bytes_until_reseed {
            // Terminal condition: we can service the request w/o reseeding.
            ringbuf_entry!(Trace::FillingBytes(num_bytes));
            self.bytes_until_reseed -= num_bytes;
            self.inner.try_fill_bytes(dest)
        } else {
            // We've been asked for bytes that exceed the reseed threshold:
            // - fill the buffer up to the threshold
            // - reseed
            // - make a recursive call to fill the rest
            ringbuf_entry!(Trace::FillingBytes(self.bytes_until_reseed));
            self.inner
                .try_fill_bytes(&mut dest[..self.bytes_until_reseed])?;
            self.reseed()?;
            ringbuf_entry!(Trace::Recurse(self.bytes_until_reseed, num_bytes));
            self.try_fill_bytes(&mut dest[self.bytes_until_reseed..])
        }
    }
}

struct Lpc55RngServer(ReseedingRng<ChaCha20Rng>);

impl Lpc55RngServer {
    fn new(
        seed: RngSeed,
        rng: Lpc55Rng,
        sn: &[u8; SUBJECT_CN_LENGTH],
        threshold: usize,
    ) -> Result<Self, Error> {
        Ok(Self(ReseedingRng::new(seed, rng, sn, threshold)?))
    }
}

impl idl::InOrderRngImpl for Lpc55RngServer {
    fn fill(
        &mut self,
        _: &userlib::RecvMessage,
        dest: idol_runtime::Leased<idol_runtime::W, [u8]>,
    ) -> Result<usize, RequestError<RngError>> {
        let mut cnt = 0;
        const STEP: usize = size_of::<u32>();
        let mut buf = [0u8; STEP];
        // fill in multiples of STEP / RNG register size
        for _ in 0..(dest.len() / STEP) {
            self.0.try_fill_bytes(&mut buf).map_err(RngError::from)?;
            dest.write_range(cnt..cnt + STEP, &buf)
                .map_err(|_| RequestError::Fail(ClientError::WentAway))?;
            cnt += STEP;
        }
        // fill in remaining
        let remain = dest.len() - cnt;
        assert!(remain < STEP);
        if remain > 0 {
            self.0.try_fill_bytes(&mut buf).map_err(RngError::from)?;
            dest.write_range(dest.len() - remain..dest.len(), &buf)
                .map_err(|_| RequestError::Fail(ClientError::WentAway))?;
            cnt += remain;
        }
        Ok(cnt)
    }
}

impl NotificationHandler for Lpc55RngServer {
    fn current_notification_mask(&self) -> u32 {
        // We don't use notifications, don't listen for any.
        0
    }

    fn handle_notification(&mut self, _bits: u32) {
        unreachable!()
    }
}

/// Load a type implementing HandoffData (and others) from a config::DataRegion.
/// Errors will be reported in the ringbuf and will return in None.
fn load_data_from_region<
    T: for<'a> Deserialize<'a> + HandoffData + SerializedSize,
>(
    region: &DataRegion,
) -> Option<T> {
    // Safety: This memory is setup by code executed before hubris and
    // exposed using the kernel `extern-regions` mechanism. The safety of
    // this code is an extension of our trust in the hubris kernel / build.
    let data = unsafe {
        slice::from_raw_parts(region.address as *mut u8, region.size as usize)
    };

    // this can be replaced w/ .ok() if we get rid of the ringbuf entry
    match T::load_from_addr(data) {
        Ok(d) => Some(d),
        Err(e) => {
            ringbuf_entry!(Trace::HandoffError(e));
            None
        }
    }
}

#[export_name = "main"]
fn main() -> ! {
    let rng_data: RngData = load_data_from_region(&RNG_DATA).unwrap_lite();
    // get cert data from handoff region
    let cert_data: CertData = load_data_from_region(&CERT_DATA).unwrap_lite();
    // get subject 'CN' from PersistIdCert 'Subject'
    let sn_bytes: [u8; SUBJECT_CN_LENGTH] =
        cert_data.persistid_cert.0.as_bytes()[SUBJECT_CN_RANGE]
            .try_into()
            .expect("fml");
    ringbuf_entry!(Trace::Sn(sn_bytes));

    let rng = Lpc55Rng::new();
    rng.init();

    let threshold = 0x100000; // 1 MiB

    let mut rng = Lpc55RngServer::new(rng_data.seed, rng, &sn_bytes, threshold)
        .expect("Failed to create Lpc55RngServer");
    let mut buffer = [0u8; idl::INCOMING_SIZE];

    loop {
        idol_runtime::dispatch(&mut buffer, &mut rng);
    }
}

mod idl {
    use drv_rng_api::RngError;

    include!(concat!(env!("OUT_DIR"), "/server_stub.rs"));
}

// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

//! API crate for the random number generator.

#![no_std]

use core::num::NonZeroU32;
#[cfg(feature = "custom-getrandom")]
use getrandom::Error as GrError;
use num::FromPrimitive;
use rand_core::impls;
pub use rand_core::{Error, RngCore};

use userlib::*;

#[repr(u32)]
#[derive(Copy, Clone, Debug, FromPrimitive)]
pub enum RngError {
    BadArg = Error::CUSTOM_START,
    PoweredOff,
}

impl From<RngError> for u16 {
    fn from(rc: RngError) -> Self {
        rc as Self
    }
}

impl From<RngError> for u32 {
    fn from(rc: RngError) -> Self {
        rc as u32
    }
}

impl From<u32> for RngError {
    fn from(u: u32) -> Self {
        match FromPrimitive::from_u32(u) {
            Some(err) => err,
            None => panic!("Invalid u32 for conversion to RngError."),
        }
    }
}

impl From<RngError> for Error {
    fn from(e: RngError) -> Self {
        match NonZeroU32::new(u32::from(e)) {
            Some(rc) => Error::from(rc),
            None => panic!("Invalid RngError for conversion to Error."),
        }
    }
}

#[cfg(feature = "custom-getrandom")]
task_slot!(RNG, rng_driver);

// This custom 'getrandom' function must be registered in the root binary crate
// before use. Once you've done this the 'getrandom' and 'rand::rngs::OsRng'.
//
// use getrandom::{getrandom, register_custom_getrandom};
// register_custom_getrandom!(rng_getrandom);
//
// fn main() {
//     let mut buf: [u8; 32] = [0; 32];
//
//     use drv_rng_api::rng_getrandom;
//     if getrandom(buf).is_ok() {
//         // do something
//     }
//
//     use rand_core::{RngCore, OsRng};
//     if OsRng.try_fill_bytes(buf).is_ok() {
//         // do something
//     }
// }
#[cfg(feature = "custom-getrandom")]
pub fn rng_getrandom(dest: &mut [u8]) -> Result<(), GrError> {
    let task_id = RNG.get_task_id();
    match Rng::from(task_id).try_fill_bytes(dest) {
        Ok(_) => Ok(()),
        // in no_std this cannot return None
        // https://docs.rs/rand_core/latest/rand_core/struct.Error.html#method.code
        Err(err) => Err(GrError::from(err.code().unwrap())),
    }
}

// struct Rng is defined in the code generated by the IDL. We implement the
// RngCore trait for this struct to allow callers to use this familiar
// interface directly or to use the Rng in interfaces with traits bound to
// RngCore.

include!(concat!(env!("OUT_DIR"), "/client_stub.rs"));

// task_slot!(RNG, rng_driver);
//
// fn main() {
//     use drv_rng_api::Rng;
//     use rand::RngCore;
//
//     let mut buf: [u8; 32] = [0; 32];
//     let rng = Rng::from(RNG.get_task_id());
//     if rng.try_fill_bytes(buf).is_ok() {
//         // do something
//     }
// }
impl RngCore for Rng {
    fn next_u32(&mut self) -> u32 {
        impls::next_u32_via_fill(self)
    }
    fn next_u64(&mut self) -> u64 {
        impls::next_u64_via_fill(self)
    }
    fn fill_bytes(&mut self, dest: &mut [u8]) {
        self.try_fill_bytes(dest)
            .expect("RNG failed to fill the provided buffer.")
    }
    fn try_fill_bytes(&mut self, dest: &mut [u8]) -> Result<(), Error> {
        match self.fill(dest) {
            Err(err) => Err(Error::from(err)),
            Ok(_) => Ok(()),
        }
    }
}

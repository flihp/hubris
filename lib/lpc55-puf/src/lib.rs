// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

#![no_std]

use core::mem;
use lpc55_pac::PUF;
use unwrap_lite::UnwrapLite;

pub struct Puf<'a> {
    puf: &'a PUF,
}

impl<'a> Puf<'a> {
    /// Given the length of the key return the size of the required PUF keycode.
    pub const fn key_to_keycode_len(key_len: usize) -> usize {
        if key_len % 8 != 0 {
            // TODO: This function should return an Option / None instead of
            // panicking here. We can't however because const_option is still
            // unstable. When https://github.com/rust-lang/rust/issues/67441
            // is merged this should be updated.
            panic!("key length not a multiple of 8");
        }

        // This is a simplified version of the formula from NXP LPC55 UM11126
        // section 48.11.7.3
        20 + (key_len + 31 & !31)
    }

    pub fn new(puf: &'a PUF) -> Self {
        Self { puf }
    }

    /// Generate a new key code for a key with the provided PUF index &
    /// length.
    /// NOTE: The PUF doesn't return the key immediately. Instead it
    /// returns a keycode through the second param. This keycode can later
    /// be used to create and return the key to the caller.
    pub fn generate_keycode(
        &self,
        index: u32,
        key_len: usize,
        keycode: &mut [u32],
    ) -> bool {
        if !self.is_generatekey_allowed() {
            panic!("PufCmdDisallowed");
        }

        // devide by sizeof u32 here because keycode param is an array of u32
        let keycode_len =
            Self::key_to_keycode_len(key_len) / mem::size_of::<u32>();
        if keycode.len() < keycode_len {
            panic!("PufKeyCode");
        }

        self.set_key_index(index);
        self.set_key_size(key_len);

        self.puf.ctrl.write(|w| w.generatekey().set_bit());
        if !self.wait_for_cmd_accept() {
            panic!("PufCmdAccept");
        }

        // while PUF is busy, read out whatever part of the KC is available
        let mut idx = 0;
        while self.is_busy() {
            if idx > keycode.len() - 1 {
                panic!("PufKCTooLong");
            }
            if self.is_keycode_part_avail() {
                let keycode_part = self.puf.codeoutput.read().bits();
                keycode[idx] = keycode_part;
                idx += 1;
            }
        }

        self.is_success()
    }

    pub fn get_key(&self, keycode: &[u32], key: &mut [u8]) -> bool {
        if !self.is_getkey_allowed() {
            panic!("DenyGetKey");
        }

        // execute CTRL function / set GETKEY bit in CTRL register, no params
        self.puf.ctrl.write(|w| w.getkey().set_bit());

        self.wait_for_cmd_accept();

        let mut kc_idx = 0;
        let mut key_idx = 0;
        // while PUF busy ... error detection?
        while self.is_busy() && !self.is_error() {
            if self.is_keycode_part_req() {
                self.puf
                    .codeinput
                    .write(|w| unsafe { w.bits(keycode[kc_idx]) });
                kc_idx += 1;
            }
            if self.is_key_part_avail() {
                for byte in self.puf.keyoutput.read().bits().to_ne_bytes() {
                    key[key_idx] = byte;
                    key_idx += 1;
                }
            }
        }

        self.is_success()
    }

    // Set key index (between 0 & 15) for a key generated by the PUF or set
    // through the API. This value is ignored for the GetKey command as the
    // index is baked into the KeyCode.
    //
    // NOTE: TL;DR: Assuming DICE is enabled, don't use index 0 or 15. Use
    // indices 1-7 if possible as we can use IDXBLK_L to disable them once
    // we're done.
    //
    // The longer version:
    // Key indices are used to identify the destination for a key when
    // it is loaded by the PUF. Keys with index 0, when loaded, are *not*
    // available through the KEYOUTPUT register. They are instead transferred
    // to the AES / PRINCE hardware engine through an internal bus. Keys with
    // index != 0 are returned for general use through the KEYOUTPUT register
    // ... except for index 15!
    //
    // Key index 15 is a special case: The ROM uses it for the DICE UDS.
    // Using this index for the UDS would be very bad given the semantics
    // above however NXP mitigates this special case by having the ROM
    // disable use of index 15 in IDXBLK_H register which it locks. This is
    // an effective mitigation (assuming the IDXBLK_H register works as
    // advertised) but it does have side effects: The ROM can't predict how
    // we'll use use key indices and so it cannot assume that indices 8 - 14
    // (also controlled by IDXBLK_H) won't be needed. The ROM leaves these
    // indices enabled when it locks IDXBLK_H and so they cannot be disabled
    // so long as DICE is enabled.
    pub fn set_key_index(&self, index: u32) -> bool {
        if index > 15 {
            return false;
        }

        // SAFETY: The PAC crate can't prevent us from setting the reserved
        // bits (the top 28) so this interface is unsafe. We ensure safety by
        // making index an unsigned type and the check above.
        self.puf.keyindex.write(|w| unsafe { w.bits(index) });

        true
    }

    // Set the size (in bytes) of the key generated by the PUF or set through
    // the API. Ths value is ignored for the GetKey command as the key size is
    // baked into the KeyCode.
    pub fn set_key_size(&self, size: usize) -> bool {
        let size: u32 = ((size * 8) >> 6).try_into().unwrap_lite();
        if size < 32 {
            // SAFETY: The PAC crate can't prevent us from setting the reserved
            // bits (the top 27) so this interface is unsafe. We ensure safety
            // by using  the type system (index is an unsigned type) and the
            // check above.
            self.puf.keysize.write(|w| unsafe { w.bits(size) });

            true
        } else {
            return false;
        }
    }

    // wait for puf to accept last command submitted
    fn wait_for_cmd_accept(&self) -> bool {
        // cmd has been accepted if either the PUF becomes busy or there's an error
        while !self.is_busy() && !self.is_error() {}

        // if there was an error the cmd was rejected
        !self.is_error()
    }

    // Block use of a particular PUF key index by setting the appropriate
    // bit in either the IDXBLK_L or IDXBLK_H register. The PUF will not
    // produce errors if asked to execute commands like GETKEY for blocked
    // key indices however the PUF will not populate the KEYOUTPUT register
    // (in experimentation KEYOUTPUT was all 0's).
    pub fn block_index(&self, index: u32) -> bool {
        match index {
            0 => false,
            1..=7 => {
                self.puf.idxblk_l.modify(|r, w| unsafe {
                    w.bits(r.bits() | 1 << (index * 2))
                });
                true
            }
            8..=15 => {
                self.puf.idxblk_h.modify(|r, w| unsafe {
                    w.bits(r.bits() | 1 << ((index - 8) * 2))
                });
                true
            }
            16.. => false,
        }
    }

    // Lock the IDXBLK_L register. This prevents changes to the PUF key
    // index blocking registers until POR.
    pub fn lock_indices_low(&self) {
        self.puf.idxblk_l.modify(|r, w| unsafe {
            w.bits(r.bits() & !(1 << 31) | (1 << 30))
        });
    }

    // Lock the IDXBLK_H register. This prevents changes to the PUF key
    // index blocking registers until POR.
    pub fn lock_indices_high(&self) {
        self.puf.idxblk_h.modify(|r, w| unsafe {
            w.bits(r.bits() & !(1 << 31) | (1 << 30))
        });
    }

    pub fn is_index_blocked(&self, index: u32) -> bool {
        match index {
            0 => panic!("invalid index"),
            1..=7 => self.puf.idxblk_l.read().bits() & (1 << (index * 2)) != 0,
            8..=15 => {
                self.puf.idxblk_h.read().bits() & (1 << ((index - 8) * 2)) != 0
            }
            16.. => panic!("invalid index"),
        }
    }

    pub fn is_busy(&self) -> bool {
        self.puf.stat.read().busy().bit()
    }

    pub fn is_error(&self) -> bool {
        self.puf.stat.read().error().bit()
    }

    pub fn is_success(&self) -> bool {
        self.puf.stat.read().success().bit()
    }

    pub fn is_ifstat_error(&self) -> bool {
        self.puf.ifstat.read().error().bit()
    }

    pub fn is_enroll_allowed(&self) -> bool {
        self.puf.allow.read().allowenroll().bit()
    }

    pub fn is_start_allowed(&self) -> bool {
        self.puf.allow.read().allowstart().bit()
    }

    pub fn is_generatekey_allowed(&self) -> bool {
        // allowsetkey controls both 'setkey' and 'generatekey' operation
        self.puf.allow.read().allowsetkey().bit()
    }

    pub fn is_getkey_allowed(&self) -> bool {
        self.puf.allow.read().allowgetkey().bit()
    }

    fn is_keycode_part_avail(&self) -> bool {
        self.puf.stat.read().codeoutavail().bit()
    }

    fn is_key_part_avail(&self) -> bool {
        self.puf.stat.read().keyoutavail().bit()
    }

    fn is_keycode_part_req(&self) -> bool {
        self.puf.stat.read().codeinreq().bit()
    }
}

#[cfg(test)]
mod tests {
    use crate::*;

    #[test]
    fn key_8_bytes() {
        assert_eq!(Puf::key_to_keycode_len(8), 52)
    }

    #[test]
    fn key_32_bytes() {
        assert_eq!(Puf::key_to_keycode_len(32), 52)
    }

    #[test]
    fn key_40_bytes() {
        assert_eq!(Puf::key_to_keycode_len(40), 84)
    }

    #[test]
    fn key_64_bytes() {
        assert_eq!(Puf::key_to_keycode_len(64), 84)
    }

    #[test]
    fn key_72_bytes() {
        assert_eq!(Puf::key_to_keycode_len(72), 116)
    }

    #[test]
    fn key_96_bytes() {
        assert_eq!(Puf::key_to_keycode_len(96), 116)
    }
}

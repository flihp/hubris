// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

#![no_std]

use core::mem;
use lpc55_pac::PUF;
use unwrap_lite::UnwrapLite;

pub struct Puf<'a> {
    puf: &'a PUF,
}

impl<'a> Puf<'a> {
    pub fn new(puf: &'a PUF) -> Self {
        Self { puf }
    }

    /// Generate a new key code for a key with the provided PUF index & length.
    pub fn generate_keycode(
        &self,
        index: u32,
        key_len: usize,
        keycode: &mut [u32]
    ) -> bool {
        if !self.is_generatekey_allowed() {
            panic!("PufCmdDisallowed");
        }

        // devide by sizeof u32 here because keycode param is an array of u32
        let keycode_len =
            key_to_keycode_len(key_len).unwrap_lite() / mem::size_of::<u32>();
        if keycode.len() < keycode_len {
            panic!("PufKeyCode");
        }

        self.set_key_index(index);
        self.set_key_size(key_len);

        self.puf.ctrl.write(|w| w.generatekey().set_bit());
        if !self.wait_for_cmd_accept() {
            panic!("PufCmdAccept");
        }

        // while PUF is busy, read out whatever part of the KC is available
        let mut idx = 0;
        while self.is_busy() {
            if idx > keycode.len() - 1 {
                panic!("PufKCTooLong");
            }
            if self.is_keycode_part_avail() {
                let keycode_part = self.puf.codeoutput.read().bits();
                keycode[idx] = keycode_part;
                idx += 1;
            }
        }
        
        self.is_success()
    }

    pub fn get_key(&self, keycode: &[u32], key: &mut [u8]) -> bool {
        if !self.is_getkey_allowed() {
            panic!("DenyGetKey");
        }

        // execute CTRL function / set GETKEY bit in CTRL register, no params
        self.puf.ctrl.write(|w| w.getkey().set_bit());

        self.wait_for_cmd_accept();

        let mut kc_idx = 0;
        let mut key_idx = 0;
        // while PUF busy ... error detection?
        while self.is_busy() && !self.is_error() {
            if self.is_keycode_part_req() {
                self.puf.codeinput.write(|w| unsafe { w.bits(keycode[kc_idx]) });
                kc_idx += 1;
            }
            if self.is_key_part_avail() {
                for byte in self.puf.keyoutput.read().bits().to_ne_bytes() {
                    key[key_idx] = byte;
                    key_idx += 1;
                }
            }
        }

        self.is_success()
    }

    // Set key index (between 0 & 15) for a key generated by the PUF or set
    // through the API. This value is ignored for the GetKey command as the index
    // is baked into the KeyCode.
    // NOTE: The only use for the key index is to send keys to hardware blocks
    // like the AES & PRINCE hardware (key index 0). Any key index != 0 is fine
    // for our purposes.
    pub fn set_key_index(&self, index: u32) -> bool {
        if index > 15 {
            return false;
        }
    
        // SAFETY: The PAC crate can't prevent us from setting the reserved
        // bits (the top 28) so this interface is unsafe. We ensure safety by
        // making index an unsigned type and the check above.
        self.puf.keyindex.write(|w| unsafe { w.bits(index) });
    
        true
    }

    // Set the size (in bytes) of the key generated by the PUF or set through
    // the API. Ths value is ignored for the GetKey command as the key size is
    // baked into the KeyCode.
    pub fn set_key_size(&self, size: usize) -> bool {
        let size: u32 = ((size * 8) >> 6).try_into().unwrap_lite();
        if size < 32 {
            // SAFETY: The PAC crate can't prevent us from setting the reserved
            // bits (the top 27) so this interface is unsafe. We ensure safety
            // by using  the type system (index is an unsigned type) and the
            // check above.
            self.puf.keysize.write(|w| unsafe { w.bits(size) });
    
            true
        } else {
            return false;
        }
    }

    // wait for puf to accept last command submitted
    fn wait_for_cmd_accept(&self) -> bool {
        // cmd has been accepted if either the PUF becomes busy or there's an error
        while !self.is_busy() && !self.is_error() {}
    
        // if there was an error the cmd was rejected
        !self.is_error()
    }

    pub fn is_busy(&self) -> bool {
        self.puf.stat.read().busy().bit()
    }
    
    pub fn is_error(&self) -> bool {
        self.puf.stat.read().error().bit()
    }
    
    pub fn is_success(&self) -> bool {
        self.puf.stat.read().success().bit()
    }

    pub fn is_ifstat_error(&self) -> bool {
        self.puf.ifstat.read().error().bit()
    }

    pub fn is_enroll_allowed(&self) -> bool {
        self.puf.allow.read().allowenroll().bit()
    }

    pub fn is_start_allowed(&self) -> bool {
        self.puf.allow.read().allowstart().bit()
    }

    pub fn is_generatekey_allowed(&self) -> bool {
        // allowsetkey controls both 'setkey' and 'generatekey' operation
        self.puf.allow.read().allowsetkey().bit()
    }

    pub fn is_getkey_allowed(&self) -> bool {
        self.puf.allow.read().allowgetkey().bit()
    }

    fn is_keycode_part_avail(&self) -> bool {
        self.puf.stat.read().codeoutavail().bit()
    }

    fn is_key_part_avail(&self) -> bool {
        self.puf.stat.read().keyoutavail().bit()
    }

    fn is_keycode_part_req(&self) -> bool {
        self.puf.stat.read().codeinreq().bit()
    }
}

/// Given the length of the key return the size of the required PUF keycode.
fn key_to_keycode_len(key_len: usize) -> Option<usize> {
    if key_len % 8 != 0 {
        return None;
    }

    // This is a simplified version of the formula from NXP LPC55 UM11126
    // section 48.11.7.3
    Some(20 + (key_len + 31 & !31))
}

#[cfg(test)]
mod tests {
    use crate::*;

    #[test]
    fn key_8_bytes() {
        assert_eq!(key_to_keycode_len(8), Some(52))
    }

    #[test]
    fn key_32_bytes() {
        assert_eq!(key_to_keycode_len(32), Some(52))
    }

    #[test]
    fn key_40_bytes() {
        assert_eq!(key_to_keycode_len(40), Some(84))
    }

    #[test]
    fn key_64_bytes() {
        assert_eq!(key_to_keycode_len(64), Some(84))
    }

    #[test]
    fn key_72_bytes() {
        assert_eq!(key_to_keycode_len(72), Some(116))
    }

    #[test]
    fn key_96_bytes() {
        assert_eq!(key_to_keycode_len(96), Some(116))
    }
}

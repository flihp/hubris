// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

use crate::{CN_LEN, ED25519_PUB_LEN, ED25519_SIG_LEN};
use std::{error, fmt, result};

#[derive(Debug, PartialEq)]
pub enum MissingFieldError {
    Cn,
    Pub,
    Sig,
    SignData,
}

impl error::Error for MissingFieldError {}

impl fmt::Display for MissingFieldError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            MissingFieldError::Cn => write!(f, "commonName not found."),
            MissingFieldError::Pub => write!(f, "No public key found in CSR."),
            MissingFieldError::Sig => {
                write!(f, "Could not find signature region.")
            }
            MissingFieldError::SignData => {
                write!(f, "Unable to find data region to sign.")
            }
        }
    }
}

type Result<T> = result::Result<T, MissingFieldError>;

// Type to expose parsing operations on CSR in underlying slice
pub struct Csr<'a>(&'a mut [u8]);

impl<'a> Csr<'a> {
    pub fn from_slice(csr: &'a mut [u8]) -> Self {
        Self(csr)
    }

    pub fn as_bytes(&self) -> &[u8] {
        self.0
    }

    pub fn len(&self) -> usize {
        self.as_bytes().len()
    }

    #[rustfmt::skip]
    const PUB_PATTERN: [u8; 12] = [
        0x30, 0x2A, 0x30, 0x05, 0x06, 0x03, 0x2B, 0x65,
        0x70, 0x03, 0x21, 0x00,
    ];
    const PUB_LEN: usize = ED25519_PUB_LEN;
    pub fn get_pub_offsets(&self) -> Result<(usize, usize)> {
        crate::get_offsets(self.0, &Self::PUB_PATTERN, Self::PUB_LEN)
            .ok_or(MissingFieldError::Pub)
    }

    #[rustfmt::skip]
    const CN_PATTERN: [u8; 11] = [
        0x31, 0x15, 0x30, 0x13, 0x06, 0x03, 0x55, 0x04,
        0x03, 0x0c, 0x0c,
    ];
    pub fn get_cn_offsets(&self) -> Result<(usize, usize)> {
        crate::get_offsets(self.0, &Self::CN_PATTERN, CN_LEN)
            .ok_or(MissingFieldError::Cn)
    }

    #[rustfmt::skip]
    const SIG_PATTERN: [u8; 10] = [
        0x30, 0x05, 0x06, 0x03, 0x2B, 0x65, 0x70, 0x03,
        0x41, 0x00,
    ];
    const SIG_LEN: usize = ED25519_SIG_LEN;
    pub fn get_sig_offsets(&self) -> Result<(usize, usize)> {
        crate::get_roffsets(self.0, &Self::SIG_PATTERN, Self::SIG_LEN)
            .ok_or(MissingFieldError::Sig)
    }

    // TODO: This is brittle. Size of the CSR will effect this offset. Smaller
    // CSRs will begin sign data at 3 bytes, larger ones at 4 bytes. This is a
    // strong argument for using a propper ASN.1 parser here.
    const SIGN_BEGIN: usize = 0x4;

    #[rustfmt::skip]
    const SIGNDATA_PATTERN: [u8; 7] = [
        0x30, 0x05, 0x06, 0x03, 0x2b, 0x65, 0x70,
    ];

    pub fn get_signdata_offsets(&self) -> Result<(usize, usize)> {
        // CSR data to sign is between offset SIGN_BEGIN & beginning of this
        // pattern in the CSR. This is the end of the certificationRequestInfo
        // field in the CSR.
        let pattern_offset =
            crate::get_pattern_roffset(self.0, &Self::SIGNDATA_PATTERN)
                .ok_or(MissingFieldError::SignData)?;

        Ok((Self::SIGN_BEGIN, pattern_offset))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    // TODO: include_bytes! from file
    #[rustfmt::skip]
    const CSR: &'static [u8] = &[
        0x30, 0x81, 0xdd, 0x30, 0x81, 0x90, 0x02, 0x01,
        0x00, 0x30, 0x5d, 0x31, 0x0b, 0x30, 0x09, 0x06,
        0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x47, 0x42,
        0x31, 0x10, 0x30, 0x0e, 0x06, 0x03, 0x55, 0x04,
        0x08, 0x0c, 0x07, 0x45, 0x6e, 0x67, 0x6c, 0x61,
        0x6e, 0x64, 0x31, 0x12, 0x30, 0x10, 0x06, 0x03,
        0x55, 0x04, 0x0a, 0x0c, 0x09, 0x41, 0x6c, 0x69,
        0x63, 0x65, 0x20, 0x4c, 0x74, 0x64, 0x31, 0x18,
        0x30, 0x16, 0x06, 0x03, 0x55, 0x04, 0x0b, 0x0c,
        0x0f, 0x41, 0x6c, 0x69, 0x63, 0x65, 0x20, 0x4c,
        0x74, 0x64, 0x20, 0x61, 0x6c, 0x69, 0x61, 0x73,
        0x31, 0x0e, 0x30, 0x0c, 0x06, 0x03, 0x55, 0x04,
        0x03, 0x0c, 0x05, 0x61, 0x6c, 0x69, 0x61, 0x73,
        0x30, 0x2a, 0x30, 0x05, 0x06, 0x03, 0x2b, 0x65,
        0x70, 0x03, 0x21, 0x00, 0x27, 0xfb, 0x87, 0x77,
        0x77, 0x36, 0x54, 0xfb, 0x78, 0xb3, 0x46, 0x6b,
        0x95, 0x0e, 0x15, 0x2b, 0x8b, 0xcd, 0x0c, 0x9b,
        0x8a, 0x08, 0xfc, 0x7a, 0xef, 0x68, 0x97, 0x1e,
        0xab, 0xa0, 0x87, 0x70, 0xa0, 0x00, 0x30, 0x05,
        0x06, 0x03, 0x2b, 0x65, 0x70, 0x03, 0x41, 0x00,
        0xf5, 0xf5, 0xcf, 0xde, 0x58, 0x87, 0x6a, 0x0e,
        0xa6, 0xb3, 0x3f, 0x23, 0x98, 0xd6, 0x97, 0x0c,
        0x3a, 0xaa, 0xb2, 0xdf, 0xa0, 0x6e, 0x5b, 0xf7,
        0xd2, 0x2b, 0x86, 0x2e, 0x05, 0xd9, 0xa4, 0x5f,
        0xe6, 0x49, 0xfc, 0xf0, 0x09, 0x66, 0x85, 0x87,
        0x6b, 0x42, 0xe6, 0xea, 0x77, 0x74, 0x55, 0x64,
        0xf8, 0x86, 0x12, 0xeb, 0x4d, 0x8d, 0xcc, 0x22,
        0xd6, 0x13, 0x5d, 0x2f, 0x47, 0xf3, 0x99, 0x03,
    ];

    #[rustfmt::skip]
    const PUB: &'static [u8] = &[
        0x27, 0xfb, 0x87, 0x77, 0x77, 0x36, 0x54, 0xfb,
        0x78, 0xb3, 0x46, 0x6b, 0x95, 0x0e, 0x15, 0x2b,
        0x8b, 0xcd, 0x0c, 0x9b, 0x8a, 0x08, 0xfc, 0x7a,
        0xef, 0x68, 0x97, 0x1e, 0xab, 0xa0, 0x87, 0x70,
    ];

    #[rustfmt::skip]
    const SIG: &'static [u8] = &[
        0xf5, 0xf5, 0xcf, 0xde, 0x58, 0x87, 0x6a, 0x0e,
        0xa6, 0xb3, 0x3f, 0x23, 0x98, 0xd6, 0x97, 0x0c,
        0x3a, 0xaa, 0xb2, 0xdf, 0xa0, 0x6e, 0x5b, 0xf7,
        0xd2, 0x2b, 0x86, 0x2e, 0x05, 0xd9, 0xa4, 0x5f,
        0xe6, 0x49, 0xfc, 0xf0, 0x09, 0x66, 0x85, 0x87,
        0x6b, 0x42, 0xe6, 0xea, 0x77, 0x74, 0x55, 0x64,
        0xf8, 0x86, 0x12, 0xeb, 0x4d, 0x8d, 0xcc, 0x22,
        0xd6, 0x13, 0x5d, 0x2f, 0x47, 0xf3, 0x99, 0x03,
    ];

    #[rustfmt::skip]
    const SIGNDATA: &'static [u8] = &[
        0x81, 0x90, 0x02, 0x01, 0x00, 0x30, 0x5d, 0x31,
        0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06,
        0x13, 0x02, 0x47, 0x42, 0x31, 0x10, 0x30, 0x0e,
        0x06, 0x03, 0x55, 0x04, 0x08, 0x0c, 0x07, 0x45,
        0x6e, 0x67, 0x6c, 0x61, 0x6e, 0x64, 0x31, 0x12,
        0x30, 0x10, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x0c,
        0x09, 0x41, 0x6c, 0x69, 0x63, 0x65, 0x20, 0x4c,
        0x74, 0x64, 0x31, 0x18, 0x30, 0x16, 0x06, 0x03,
        0x55, 0x04, 0x0b, 0x0c, 0x0f, 0x41, 0x6c, 0x69,
        0x63, 0x65, 0x20, 0x4c, 0x74, 0x64, 0x20, 0x61,
        0x6c, 0x69, 0x61, 0x73, 0x31, 0x0e, 0x30, 0x0c,
        0x06, 0x03, 0x55, 0x04, 0x03, 0x0c, 0x05, 0x61,
        0x6c, 0x69, 0x61, 0x73, 0x30, 0x2a, 0x30, 0x05,
        0x06, 0x03, 0x2b, 0x65, 0x70, 0x03, 0x21, 0x00,
        0x27, 0xfb, 0x87, 0x77, 0x77, 0x36, 0x54, 0xfb,
        0x78, 0xb3, 0x46, 0x6b, 0x95, 0x0e, 0x15, 0x2b,
        0x8b, 0xcd, 0x0c, 0x9b, 0x8a, 0x08, 0xfc, 0x7a,
        0xef, 0x68, 0x97, 0x1e, 0xab, 0xa0, 0x87, 0x70,
        0xa0, 0x00,
    ];

    // Test init function to create a mutable array with the CSR copied from
    // the const CSR
    const fn init<const N: usize>(a: &[u8]) -> [u8; N] {
        let mut res = [0u8; N];

        let mut i: usize = 0;
        while i < N {
            res[i] = a[i];
            i += 1;
        }

        res
    }

    #[test]
    fn get_pub_offsets() {
        let mut csr: [u8; CSR.len()] = init(CSR);
        let csr = Csr::from_slice(&mut csr);
        let (start, end) =
            csr.get_pub_offsets().map_err(|e| panic!("{}", e)).unwrap();
        assert_eq!(&csr.as_bytes()[start..end], PUB);
    }

    #[test]
    fn get_sig_offsets() {
        let mut csr: [u8; CSR.len()] = init(CSR);
        let csr = Csr::from_slice(&mut csr);
        let (start, end) =
            csr.get_sig_offsets().map_err(|e| panic!("{}", e)).unwrap();
        assert_eq!(&csr.as_bytes()[start..end], SIG);
    }

    #[test]
    fn get_signdata_offsets() {
        let mut csr: [u8; CSR.len()] = init(CSR);
        let csr = Csr::from_slice(&mut csr);
        let (start, end) = csr
            .get_signdata_offsets()
            .map_err(|e| panic!("{}", e))
            .unwrap();
        assert_eq!(&csr.as_bytes()[start..end], SIGNDATA);
    }

    #[test]
    fn get_signdata_offsets_bad() {
        let mut csr = [0u8; 10];
        let csr = Csr::from_slice(&mut csr);
        assert_eq!(
            csr.get_signdata_offsets(),
            Err(MissingFieldError::SignData)
        );
    }
}

// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

#![no_std]
#![no_main]

use dice::{Cdi, Csr, DeviceIdOkm, Msg, Msgs, SEED_LENGTH};
use lib_lpc55_usart::Usart;
use lpc55_pac as device;
use ringbuf::{ringbuf, ringbuf_entry};
use salty::signature::Keypair;
use sha1::{Digest, Sha1};
use userlib::{hl, UnwrapLite};

cfg_if::cfg_if! {
    // if we're talking to tasks get their TaskIds & configuration data
    if #[cfg(feature = "tasks")] {
        use drv_rng_api::Rng;
        use rand::RngCore;
        use userlib::{task_slot, TaskId};

        task_slot!(GPIO, gpio_driver);
        task_slot!(RNG, rng_driver);

        include!(concat!(env!("OUT_DIR"), "/pin_config.rs"));
    }
}

#[derive(Copy, Clone, PartialEq)]
enum Trace {
    SerialNumber([u8; 12]),
    CsrFillTemplate,
    CsrSign,
    PublicKey([u8; SEED_LENGTH]),
    SubjectKeyIdentifier([u8; 20]),
    GotKeyPairFromOkm,
    MaxEncodedBufSize(usize),
    EncodedBufSize(usize),
    PollForCsrPlz,
    PollForCert,
    RecvCsrPlz(u32),
    RecvCert(u32),
    SendCsr(u32),
    BadState,
    UsartError(lib_lpc55_usart::Error),
    Done,
    None,
}

ringbuf!(Trace, 64, Trace::None);

// This is effectively a mock function. The real serial number will come
// from persistent storage
fn get_sn() -> [u8; 12] {
    let mut dst = [0u8; 12];

    cfg_if::cfg_if! {
        if #[cfg(feature = "tasks")] {
            let mut buf = [0u8; 12];
            let mut rng = Rng::from(RNG.get_task_id());
            rng.try_fill_bytes(&mut buf).expect("try_fill_bytes");

            // can't use iter / map till https://github.com/rust-lang/rust/issues/81615
            // map to [0-9A-Za-z]
            for (i, byte) in buf.iter().enumerate() {
                let mapped = byte % (10 + 26 + 26);
                dst[i] = match mapped {
                    0..=9 => (mapped + 48),
                    10..=36 => (mapped + 65 - 10),
                    37..=63 => (mapped + 97 - 37),
                    _ => panic!("WTF"),
                };
            }
        } else {
            dst.copy_from_slice("deadbeefcafe".as_bytes());
        }
    }

    dst
}

#[export_name = "main"]
fn main() -> ! {
    let cdi = match Cdi::new() {
        Some(cdi) => cdi,
        None => panic!("DICE disabled: CDI is 0"),
    };

    let devid_okm = DeviceIdOkm::from_cdi(&cdi);

    let keypair = Keypair::from(devid_okm.as_bytes());
    ringbuf_entry!(Trace::GotKeyPairFromOkm);

    let public_key = &keypair.public;
    ringbuf_entry!(Trace::PublicKey(public_key.to_bytes()));

    // This is for demo purposes only. We don't need to calculate the 'subject
    // key identifier', we just do so to provide a link beteween the data shown
    // by the RoT ringbuf & the cert generated by the CA.
    let mut ski_hash = Sha1::new();
    ski_hash.update(public_key.to_bytes());
    let ski = ski_hash.finalize();
    ringbuf_entry!(Trace::SubjectKeyIdentifier(
        ski[..].try_into().unwrap_lite()
    ));

    let sn = get_sn();
    ringbuf_entry!(Trace::SerialNumber(sn));

    let mut csr = Csr::new(&sn);
    ringbuf_entry!(Trace::CsrFillTemplate);

    csr.sign(&keypair).expect("Failed to sign CSR.");
    ringbuf_entry!(Trace::CsrSign);

    let peripherals = device::Peripherals::take().unwrap_lite();

    let usart = peripherals.USART0;
    let flexcomm0 = peripherals.FLEXCOMM0;

    cfg_if::cfg_if! {
        if #[cfg(feature = "tasks")] {
            // config Usart through the GPIO & SYSCON tasks
            userlib::task_slot!(GPIO, gpio_driver);

            let gpio_driver = GPIO.get_task_id();
            setup_pins(gpio_driver).unwrap_lite();

            let mut usart = Usart::turn_on(&flexcomm0, &usart);
        } else {
            // config Usart through PAC interface
            let iocon = peripherals.IOCON;
            let syscon = peripherals.SYSCON;

            let mut usart = Usart::turn_on(&syscon, &iocon, &flexcomm0, &usart);
        }
    }

    ringbuf_entry!(Trace::MaxEncodedBufSize(Msg::MAX_ENCODED_SIZE));
    let mut data = [0xFFu8; Msg::MAX_ENCODED_SIZE];

    loop {
        // wait for msg from uart
        ringbuf_entry!(Trace::PollForCsrPlz);
        let msg = match usart.read_until(&mut data, &[0]) {
            Ok(size) => Msg::from(&data[..size]),
            Err(e) => {
                ringbuf_entry!(Trace::UsartError(e));
                continue;
            }
        };

        match msg.msg {
            Msgs::CsrPlz => ringbuf_entry!(Trace::RecvCsrPlz(msg.id)),
            _ => {
                ringbuf_entry!(Trace::BadState);
                continue;
            }
        }

        data.fill(0);
        hl::sleep_for(100);

        // send CSR
        let msg = Msg {
            id: msg.id + 1,
            msg: Msgs::Csr(csr),
        };

        let size = msg.encode(&mut data);
        ringbuf_entry!(Trace::EncodedBufSize(size));

        usart.write_all(&data[..size]).expect("write_all?");
        ringbuf_entry!(Trace::SendCsr(msg.id));

        data.fill(0);
        hl::sleep_for(100);

        // read back cert
        ringbuf_entry!(Trace::PollForCert);
        let msg = match usart.read_until(&mut data, &[0]) {
            Ok(size) => Msg::from(&data[..size]),
            Err(e) => {
                ringbuf_entry!(Trace::UsartError(e));
                continue;
            }
        };

        match msg.msg {
            Msgs::Cert(_) => ringbuf_entry!(Trace::RecvCert(msg.id)),
            _ => {
                ringbuf_entry!(Trace::BadState);
                continue;
            }
        }

        data.fill(0);
        hl::sleep_for(100);
        ringbuf_entry!(Trace::Done);
    }
}
